\nonstopmode
\documentclass[10pt, a4paper]{article}
\parindent=20pt
\parskip=8pt
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}	
\usepackage{framed, color}
\definecolor{shadecolor}{gray}{0.95}
\usepackage{amsmath,amsfonts,amsthm}				
\usepackage[pdftex]{graphicx}								% Enable pdflatex
\usepackage[svgnames]{xcolor}						
\usepackage{geometry}
	\textheight=700px								
\usepackage{url}									
\usepackage{wrapfig}								
\usepackage{bbding}	
\textheight = 650pt
\footskip = 30pt

\author{Seguridad Android.}
\date{}								% Symbols
\begin{document}

\thispagestyle{empty}

\begin{center}

\vspace{2cm}

Departamento de Computación,\\
$22^{\circ}$ Escuela de Verano de Ciencias Informáticas,\\
Universidad Nacional de Río Cuarto

\vspace{4cm}

\begin{Huge}
Seguridad y Protección de datos en aplicaciones Android\end{Huge}

\vspace{0.5cm}

\begin{huge}
Trabajo Práctico Final
\end{huge}

\vspace{1cm}

Febrero de 2015

\vspace{8cm}


\vspace{1cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & Universidad & E-mail\\
\hline
Izcovich, Sabrina     & UBA & sizcovich@gmail.com\\
Vita, Sebastián       & UBA & sebastian\_vita@yahoo.com.ar\\
\hline
\end{tabular}

\end{center}

\newpage
\tableofcontents
\newpage

\section{Introducción}
En el siguiente trabajo práctico, debimos analizar la aplicación Android $BadBrowser$ con el fin de hallar sus vulnerabilidades. La misma se trata de un navegador que permite sincronizar el historial de un usuario registrado con un servidor externo. Dicha aplicación contiene vulnerabilidades del tipo de las vistas en el curso, que pueden ser:
\begin{itemize}
\item \textbf{LOCALES}
\begin{itemize}
\item \textbf{DATOS MAL PROTEGIDOS}
\item \textbf{COMPONENTES MAL EXPORTADOS}
\end{itemize}
\item \textbf{DE RED}
\begin{itemize}
\item \textbf{ACTIVAS}
\item \textbf{PASIVAS}
\end{itemize}
\item \textbf{REMOTAS}
\end{itemize}

Con el fin de hallarlas, debimos realizar un análisis dinámico y otro estático de la aplicación. Para esto último, fue necesario descargar la última actualización de $android-apktool$\footnote{https://code.google.com/p/android-apktool/} (v2.0.0RC4) dentro de la máquina virtual provista por la cátedra como también decompilar la aplicación para acceder a su código fuente.
Para una correcta experimentación, se nos proveyó de los fuentes del servidor externo para que pudiera ser corrido utilizando python.

\newpage
\section{Análisis}

\subsection{Manifest}

En primer lugar, decidimos analizar el $Manifest$, archivo en el que se enumeran las actividades, los servicios, los receptores, los proveedores de contenidos y los permisos requeridos por la aplicación. 

Las configuraciones encontradas fueron las siguientes:
\begin{itemize}
\item \begin{verbatim}<permission android:name="ar.sadosky.badbrowser.permission.SyncBrowser"/> \end{verbatim} 
\item \begin{verbatim}<permission
android:name="ar.sadosky.badbrowser.permission.WRITE"
android:protectionLevel="signature"/> \end{verbatim}

Estos dos permisos son exportados por la aplicación. El primero permite sincronizar los datos del browser utilizando la cuenta creada. El segundo indica que el nivel de protección es de tipo ``signature'', lo que significa que es sólo accesible a aplicaciones firmadas con el mismo certificado que la que registra el permiso.

\item \begin{verbatim} application android:allowBackup="true" \end{verbatim}

Esta configuración presenta una vulnerabilidad de tipo \textit{Almacenamiento inseguro de datos privados} pues se almacena la información sin ningún tipo de encriptación. Esto se considera un problema de seguridad pues una persona podría realizar un backup de la aplicación por medio de $adb$ y obtener datos privados de la misma en sus computadoras.


\item \begin{verbatim}
<provider android:authorities="ar.sadosky.browser.history_provider"
android:exported="true"
android:name="ar.sadosky.badbrowser.HistoryProvider"
android:writePermission="ar.sadosky.badbrowser.permission.WRITE"/>
\end{verbatim}

La configuración anterior le da al provider el permiso de ser exportado públicamente (a través de $exported=`true''$). 
Dado que no se exhibe ninguna configuración sobre los permisos de tipo lectura, no se impide que las aplicaciones externas puedan leer el historial de los usuarios, presentando una vulnerabilidad de tipo \textit{Almacenamiento inseguro de datos privados}. 

\end{itemize}

Consideramos que el resto de las configuraciones están bien adaptadas a los fines de la aplicación y no presentan relevancia, por lo que decidimos no mencionarlas.

\newpage
\subsection{Browser Server}
Luego, procedimos analizando el $browser\_server.py$ con el fin de hallar las posibles fallas presentes en el mismo:
En primer lugar, para cada $login$ que se realiza en la aplicación, se genera y guarda en un conjunto una string de identificación de sesión ($session\_key$) que se envía codificada al usuario utilizando AES como algoritmo de encriptación. Dado que no hay ningún tipo de mecanisimo en el código para caducar o borrar las sesiones activas, un atacante podría generar múltiples logins de forma masiva sin que la aplicación rechaze los pedidos, pudiento realizar un DOS llenando la memoria RAM del servidor.

Por otra parte, al registrarse, el servidor guarda el $uuid$ y la $password$ del usuario sin ninguna medida de seguridad o verificación de operaciones de registros masivos por parte de usuarios, ni sobre la posibilidad de realizar registros utilizando el mismo $uuid$.

A continuación, se plantean los siguientes ataques:
\begin{shaded}
\begin{itemize}
\item Un atacante podría realizar un DOS llenando la memoria del servidor al forzar a guardarse registros de forma masiva, de los cuales, tampoco verifica el largo de los campos ingresados, siendo fácil su ejecución.
\item Un atacante podría sobrescribir el registro de otro usuario, utilizando su mismo $uuid$, pudiendo cambiar su contraseña.
\end{itemize}
\end{shaded}

Otra vulnerabilidad ocurre al realizar peticiones a $/sync$ POST y GET. Tanto para el $/sync$ POST como para el GET, solo se verifica que la $session\_key$ exista en el conjunto de keys activas que el servidor posee. Este error expone a un atacante la posibilidad de poder subir, utilizando POST, o leer, utilizando GET, el contenido de cualquier otro usuario solo con utilizar una $session\_key$ que se haya utilizado anteriormente, que como vimos antes, nunca caducan.

Se pueden plantear los siguentes ataques:
\begin{shaded}
\begin{itemize}
\item Un atacante podría utilizar su $session\_key$ o capturar un mensaje a $/sync$ y reutilizarlo, cambiando el campo $email$ que identifica al dueño del contenido a leer o subir, pudiendo leer el contenido guardado por cualquier usuario, o cambiando el campo referido al contenido de lo que será guardado, sobrescribir el contenido guardado por otro usuario.
\item Un atacante puede utilizar una $session\_key$ válida de las maneras nombradas anteriormente y realizar una peticion GET a $/sync$ donde el campo mail sea conocido por el atacante, pudiendo obtener el contenido de su historial sincronizado.
\item Al no tener ningún tipo de verificación al subir el contenido, podría realizarse un DOS enviando mensajes POST de forma masiva a $/sync$ con alguna $session\_key$ válida, mails frescos como campo para guardar nuevo contenido y contenido pesado para terminar con el agotamiento de la memoria del servidor.
\end{itemize}
\end{shaded}



Los problemas encontrados fueron los que siguen:

\begin{itemize}

\item \textbf{Vulnerabilidad Remota:} Al observar los \texbf{def encrypt(self,value)} y \texbf{def decrypt(self,value)}, notamos que la clave secreta del cipher simétrico se encuentra hardcodeada. Usualmente, las mismas se generan de forma $random$ a través de alguna función provista por el lenguaje. 
Por otro lado, dado que el cipher se encuentra en modo CBC, la reutilización de un IV puede facilitar información sobre el primer bloque de texto plano, el largo y cualquier prefijo compartido entre dos mensajes.
Esto se debe a que si no se cambia el IV en cada sesión, los datos están mayormente sujetos a ataques como podría ser el análisis estático criptográfico, capaz de develar la clave. 

De este modo, hallamos que el diseño de proceso de encriptación es débil.

Este tipo de problemas podría generar el siguiente escenario:

Supongamos que somos víctimas de un ataque de tipo ``Man in the middle''. Dado que la $session\_key$ se encripta con el mismo par (IV, clave) y la información que se transfiere durante la conexión puede repetirse, alcanza con un análisis estadístico criptográfico para conocer la clave secreta de encriptación, para luego, desencriptar el mensaje del usuario.

\item \textbf{Vulnerabilidad Remota:} Descubrimos un problema de autenticación al validar la identidad de un sujeto: el sistema mantiene soporte para un único usuario. Cada vez que se registra un usuario nuevo con su mail y clave, los datos del mismo pisan los del usuario anterior en la base de datos dado que no se itera sobre la misma. Además, cuando esta persona usa la aplicación, el historial que genera se agrega al del usuario anterior. Esto se debe a que se almacena un único historial para todos los usuarios.

Esta vulnerabilidad permite que cuando un usuario se registra en la aplicación, pueda ver el historial de la última persona logueada.

Por otro lado, la cuenta no se bloquea tras X intentos fallidos, por lo que se podrían intentar distintas claves indefinidamente. Además, el mail de los usuarios no se almacena en ningún momento. 

\item \textbf{Componentes mal exportados:} No se utiliza SSL ni TLS como protocolos criptográficos para proporcionar comunicaciones seguras por la red, generando una transmisión insegura de los datos. Esto se debe a que en vez de correr sobre HTTPS, el servidor corre sobre HTTP, dando la posibilidad de sniffear (\textbf{ataque pasivo}) y/o modificar (\textbf{ataque activo}).

\item \textbf{Ataque de red activo:} Se puede alterar el historial enviado en una petición POST a $/sync$ a través de un ataque man in the middle Man in The Middle. Esto se debe a que con un simple $query$ de $adb$ es posible obtener el historial almacenado en el celular del usuario.

\item \textbf{Ataque de red pasivo:} Existe la posibilidad de sniffear y ver los datos/historial de una persona dado que toda la información se envía mediante el protocolo HTTP. Para esto, basta con utilizar un analizador de red, como ser $Scapy$, y capturar toda la información que se dirige al servidor.

\item \textbf{Datos mal protegidos:} La información se envía encriptada con una clave que se encuentra hardcodeada en el código, luego se la encripta con base 64. Con lo cual, todos los datos que se envían a través del browser pueden ser desencriptados fácilmente. Por otro lado, el historial de todos los usuarios se almacena en el mismo lugar, con lo cual cualquier usuario podría leer el historial de los demás.

Cuando un usuario guarda un sitio al que ingresa con HTTPS en el historial, el mismo se guarda con HTTP entonces cuando vuelve a ingresar entra con HTTP.


\end{itemize}

\newpage
\section{Prueba de Concepto}

Una posible prueba de concepto para mostrar una vulnerabilidad de tipo local consiste en realizar un $adb$ $query$ con el fin de obtener el historial del usuario del teléfono:

Para ello, es menester correr la aplicación y, en una terminal, escribir el siguiente comando:

\begin{verbatim}
adb shell content query --uri "content://ar.sadosky.browser.history_provider/history"
\end{verbatim}

Como se puede observar, es muy simple acceder al historial del usuario sin necesidad de ningún tipo de información, exponiendo la vulnerabilidad local de $BadBrowser$.

\newpage
\section{Conclusión}

A partir de un exhaustivo análisis dinámico y estático de la aplicación $BadBrowser$, encontramos distintos problemas de seguridad. Entre ellos, se pueden ver algunos de tipo transmisión insegura, almacenamiento inseguro de datos privados, autenticación/autorización pobres y mal uso de criptografía. 

Entre las vulnerabilidades descubiertas, notamos que la aplicación se comunica con servidores externos utilizando un protocolo inseguro y exporta servicios de manera incorrecta, pudiento los atacantes:
\begin{itemize}
\item Interferir y recolectar información privada por los protocolos sin encriptación.
\item Alterar y/o conseguir el historial privado de los usuarios de forma remota sin una dificultad aparente de forma remota.
\item Conseguir el historial de los usuarios de forma local utilizando ADB o alguna aplicación, mediante el content provider mal exportado.
\end{itemize}

Concluimos además, que el cifrado utilizado para la $session_key$ puede ser vulnerado debido a que la utilización de un único IV puede permitir ataques estadísticos criptográficos que podrían resultar en la obtención de la clave secreta del cifrado.

\end{document}