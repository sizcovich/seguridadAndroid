\nonstopmode
\documentclass[10pt, a4paper]{article}
\parindent=20pt
\parskip=8pt
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}	
\usepackage{framed, color}
\definecolor{shadecolor}{gray}{0.95}
\usepackage{amsmath,amsfonts,amsthm}				
\usepackage[pdftex]{graphicx}								% Enable pdflatex
\usepackage[svgnames]{xcolor}						
\usepackage{geometry}
	\textheight=700px								
\usepackage{url}									
\usepackage{wrapfig}								
\usepackage{bbding}	


\author{Seguridad Android.}
\date{}								% Symbols
\begin{document}

\thispagestyle{empty}

\begin{center}

\vspace{2cm}

Departamento de Computación,\\
$22^{\circ}$ Escuela de Verano de Ciencias Informáticas,\\
Universidad Nacional de Río Cuarto

\vspace{4cm}

\begin{Huge}
Seguridad y Protección de datos en aplicaciones Android\end{Huge}

\vspace{0.5cm}

\begin{huge}
Trabajo Práctico Final
\end{huge}

\vspace{1cm}

Febrero de 2015

\vspace{8cm}


\vspace{1cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & Universidad & E-mail\\
\hline
Izcovich, Sabrina     & UBA & sizcovich@gmail.com\\
Vita, Sebastián       & UBA & sebastian\_vita@yahoo.com.ar\\
\hline
\end{tabular}

\end{center}

\newpage
\tableofcontents
\newpage

\section{Introducción}
En el siguiente trabajo práctico, debimos analizar la aplicación Android $BadBrowser$ con el fin de hallar sus vulnerabilidades. La misma se trata de un navegador que permite sincronizar el historial de un usuario registrado con un servidor externo. Dicha aplicación contiene vulnerabilidades del tipo de las vistas en el curso, que pueden ser:
\begin{itemize}
\item \textbf{LOCALES}
\begin{itemize}
\item \textbf{DATOS MAL PROTEGIDOS}
\item \textbf{COMPONENTES MAL EXPORTADOS}
\end{itemize}
\item \textbf{DE RED}
\begin{itemize}
\item \textbf{ACTIVAS}
\item \textbf{PASIVAS}
\end{itemize}
\item \textbf{REMOTAS}
\end{itemize}

Con el fin de hallarlas, debimos realizar un análisis dinámico y uno estático de la aplicación. Para esto último, fue necesario descargar la última actualización de $android-apktool$\footnote{https://code.google.com/p/android-apktool/} (v2.0.0RC4) dentro de la máquina virtual provista por la cátedra como también decompilar la aplicación para acceder a su código fuente.
Para una correcta experimentación, se nos proveyó de los fuentes del servidor externo para que pudiera ser corrido utilizando python.

\newpage
\section{Análisis}

\subsection{Manifest}

En primer lugar, decidimos analizar el $Manifest$, archivo en el que se enumeran las actividades, los servicios, los receptores, los proveedores de contenidos y los permisos requeridos por la aplicación. 

Las configuraciones encontradas fueron las siguientes:
\begin{itemize}
\item \begin{verbatim}<permission android:name="ar.sadosky.badbrowser.permission.SyncBrowser"/> \end{verbatim} 
\item \begin{verbatim}<permission
android:name="ar.sadosky.badbrowser.permission.WRITE"
android:protectionLevel="signature"/> \end{verbatim}

Estos dos permisos son exportados por la aplicación. El primero permite sincronizar los datos del browser utilizando la cuenta creada. El segundo indica que el nivel de protección es de tipo ``signature'', lo que significa que es sólo accesible a aplicaciones firmadas con el mismo certificado que la que registra el permiso.

\item \begin{verbatim} application android:allowBackup="true" \end{verbatim}

Esta configuración presenta una vulnerabilidad de tipo \textit{Almacenamiento inseguro de datos privados} pues se almacena la información sin ningún tipo de encriptación. Esto se considera un problema de seguridad pues una persona podría realizar un backup de la aplicación por medio de $adb$ y obtener datos privados de la misma en sus computadoras.


\item \begin{verbatim}
<provider android:authorities="ar.sadosky.browser.history_provider"
android:exported="true"
android:name="ar.sadosky.badbrowser.HistoryProvider"
android:writePermission="ar.sadosky.badbrowser.permission.WRITE"/>
\end{verbatim}

La configuración anterior le da al provider el permiso de ser exportado públicamente (a través de $exported=`true''$). 
Dado que no se exhibe ninguna configuración sobre los permisos de tipo lectura, no se impide que las aplicaciones externas puedan leer el historial de los usuarios, presentando una vulnerabilidad de tipo \textit{Almacenamiento inseguro de datos privados}. 

\end{itemize}

Consideramos que el resto de las configuraciones están bien adaptadas a los fines de la aplicación y no presentan relevancia, por lo que decidimos no mencionarlas.

\newpage
\subsection{Browser Server}
Luego, procedimos analizando el $browser\_server.py$ con el fin de hallar las posibles fallas presentes en el mismo:

\begin{shaded}
En primer lugar, para cada $login$ que se realiza en la aplicación, se genera un string de identificación de sesión que se envía codificado luego del login de usuario. Luego, el servidor guarda la $session\_key$ sin encriptar en un conjunto de keys. Dado que no hay ningún tipo de verificación en el código, un atacante podría generar múltiples logins sin que la aplicación presente problemas. Por otro lado, como no se borran ni caducan los datos del conjunto donde se guardan las keys, se podría hacer un DOS llenando la memoria RAM.

Por otra parte, cuando un usuario se registra, podría registrarse múltiples veces dado que no hay ningún tipo de chequeo. Del mismo modo, podría hacer un DOS y llenar la memoria del servidor. Podría ocurrir que un usuario genere miles de registros y hacer crecer el archivo indefinidamente hasta llenar la capacidad.

Luego, cuando la aplicación recibe el email y la $session\_key$ cifrada que se le envió al usuario al momento del login, si se interfiere en el /sync POST, se puede repetir el mensaje con la $session\_key$ cifrada, inclusive y variar o no el parámetro email, pudiendo alterar el contenido ya guardado o crear nuevo proveyendo otro mail. Es posible también realizar un DOS, guardando una cantidad enorme de datos mediante una sucesión de peticiones POST a /sync usando una $session\_key$ capturada.
\end{shaded}


Los problemas encontrados fueron los que siguen:

\begin{itemize}

\item \textbf{Vulnerabilidad Remota:} Al observar los \texbf{def encrypt(self,value)} y \texbf{def decrypt(self,value)}, notamos que la clave secreta del cipher simétrico se encuentra hardcodeada. Usualmente, las mismas se generan de forma $random$ a través de alguna función provista por el lenguaje. 
Por otro lado, dado que el cipher se encuentra en modo CBC, la reutilización de un IV puede facilitar información sobre el primer bloque de texto plano, el largo y cualquier prefijo compartido entre dos mensajes.
Esto se debe a que si no se cambia el IV en cada sesión, los datos están mayormente sujetos a ataques como podría ser el análisis estático criptográfico, capaz de develar la clave. 

De este modo, hallamos que el diseño de proceso de encriptación es débil.

Este tipo de problemas podría generar el siguiente escenario:

Supongamos que somos víctimas de un ataque de tipo ``Man in the middle''. Dado que la $session\_key$ se encripta con el mismo par (IV, clave) y la información que se transfiere durante la conexión puede repetirse, alcanza con un análisis estadístico criptográfico para conocer la clave secreta de encriptación, para luego, desencriptar el mensaje del usuario.

\item \textbf{Vulnerabilidad Remota:} Hallamos un problema de autenticación al validar la identidad de un sujeto: el sistema mantiene soporte para un único usuario. Cada vez que se registra un usuario nuevo con su mail y clave, los datos del mismo pisan los del usuario anterior en la base de datos dado que no se itera sobre la misma. Además, cuando esta persona usa la aplicación, el historial que genera se agrega al del usuario anterior. Esto se debe a que se almacena un único historial para todos los usuarios.

Esta vulnerabilidad permite que cuando un usuario se registra en la aplicación, pueda ver el historial de la última persona logueada.

Por otro lado, la cuenta no se bloquea tras X intentos fallidos, por lo que se podrían intentar distintas claves indefinidamente. Además, el mail de los usuarios no se almacena en ningún momento. 

\item \textbf{Transmisión insegura:} No se utiliza SSL ni TLS como protocolos criptográficos para proporcionar comunicaciones seguras por la red. Esto se puede ver dado que en vez de correr sobre HTTPS, el servidor corre sobre HTTP, dando la posibilidad de sniffear (\textbf{ataque pasivo}) y modificar (\textb{fataque activo}) los requests y responses.

\item \textbf{Ataque de red activo:} Se puede alterar el historial y setearlo manualmente a través de un Man in The Middle.

\item \textbf{Ataque de red pasivo:} Sniffear y ver los datos/historial de una persona, provocando que se pueda ingresar al historial de cualquier ingresando únicamente la clave del atacante.

\item \textbf{Datos mal protegidos:} La clave para encriptar es base 64 de lo que está encriptado. Luego, todos los datos que se envían a través del browser pueden ser desencriptados fácilmente. 

\item \textbf{Componentes mal exportados:} Se puede leer el historial de un usuario dado que no se almacena con HTTPS sino que con HTTP.

Cuando un usuario guarda un sitio al que ingresa con HTTPS en el historial, el mismo se guarda con HTTP entonces cuando vuelve a ingresar entra con HTTP. Ver MainActivity.class

\end{itemize}

\newpage
\section{Prueba de Concepto}

Una posible prueba de concepto para mostrar una vulnerabilidad de tipo local consiste en realizar un $adb$ $query$ con el fin de obtener el historial del usuario del teléfono:

Para ello, es menester correr la aplicación y, en una terminal, escribir el siguiente comando:

\begin{verbatim}
adb shell content query --uri "content://ar.sadosky.browser.history_provider/history"
\end{verbatim}

Como se puede observar, es muy simple acceder al historial del usuario sin necesidad de ningún tipo de información, exponiendo la vulnerabilidad local de $BadBrowser$.
\end{document}